# UIView

## initializer

### init with tag

```swift
init(tag: Int)
```
|  parameter | 型 | description |
| ---- | ---- | ---- |
| tag | Int | tag of view |

### init with assign

Initializer with parameters to assign to class parameters

```swift
init<T>(assign variable: inout T)
```

#### sample

```swift
import UIKit
import DeclarativeUIKit

final class MainViewController: UIViewController {
    
    private weak var mainLabel: UILabel!
    
    override func loadView() {
        super.loadView()
        
        self.declarative {
            UILabel(assign: &mainLabel)
                .text("text")
                .font(.systemFont(ofSize: 20))
        }
    }
    
    func configure(text: String) {
        mainLabel.text = text
    }
}
```

### spacer

Generates a View with `isUserInteractionEnabled` set to `false

```swift
static func spacer() -> UIView
```

### divider

Generates a View with `isUserInteractionEnabled` set to `false`, `height` to `0.5` and `backgroundColor` to `lightGray`

```swift
static func divider() -> UIView
```

## function

### declarative

Declaratively describe the UIView in the builder parameter of the declarative

```swift
func declarative(priorities: UIEdgePriorities, _ builder: () -> UIView)
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| priorities | [UIEdgePriorities](parameter.md#uiedgepriorities) | Priorities for the top, bottom, left and right constraints of the View generated by the builder parameter, defaults to all `required` |
| builder | () -> UIView | Declaratively describe the layout of the UIView |

#### sample

Sample of lining up `UILabel` and `UIImageView`.

```swift
import UIKit
import DeclarativeUIKit

final class SampleView: UIView {

    override init(frame: CGRect) {
        super.init(frame: frame)
        
          self.declarative {
            UIStackView {
                UILabel("aa").font(UIFont.systemFont(ofSize: 30))

                UIStackView.horizontal {
                    UIView.spacer()
                    UIImageView(UIImage(systemName: "pencil"))
                        .size(width: 100, height: 100)
                    UIView.spacer()
                }

                UIView.spacer()
            }
        }
    }
}

```

### imperative

Methods to implement `UIView` parameters procedurally as standard

```swift
func imperative(_ imperative: ((Self) -> Void)) -> Self

static func imperative(_ imperative: ((Self) -> Void)) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| imperative | ((Self) -> Void) | Write parameters imperatively internally by passing themselves as arguments |

#### sample

Here is a sample that sets the parameters of `UILabel` imperatively

```swift
self.declarative {
    UIStackView {
        UILabel.imperative {
            let label = $0 as! UILabel
            label.text = "sample1"
            label.font = UIFont.systemFont(ofSize: 20)
            label.textColor = .red
        }
        UILabel("sample2").imperative {
            let label = $0 as! UILabel
            label.font = UIFont.systemFont(ofSize: 20)
            label.textColor = .blue
        }
        UIView.spacer()
    }
}
```

### assign

Assign to class parameters

```swift
func assign<T>(to variable: inout T) -> Self
```

#### sample

```swift
import UIKit
import DeclarativeUIKit

final class MainViewController: UIViewController {
    
    private weak var mainLabel: UILabel!
    
    override func loadView() {
        super.loadView()
        
        self.declarative {
            UILabel("text")
                .font(.systemFont(ofSize: 20))
                .assign(to: &mainLabel)
        }
    }
    
    func configure(text: String) {
        mainLabel.text = text
    }
}
```

### some default parameters

The following standard parameters can be written declaratively

```swift
func tag(_ tag: Int) -> Self

func backgroundColor(_ backgroundColor: UIColor) -> Self

func isUserInteractionEnabled(_ isUserInteractionEnabled: Bool) -> Self

func clipsToBounds(_ clipsToBounds: Bool) -> Self

func contentMode(_ contentMode: ContentMode) -> Self

func alpha(_ alpha: CGFloat) -> Self

func isHidden(_ isHidden: Bool) -> Self

func isShow(_ isShow: Bool) -> Self //isHiddenの逆

func transform(_ transform: CGAffineTransform) -> Self

func contentHuggingPriority(_ priority: UILayoutPriority, for axis: NSLayoutConstraint.Axis) -> Self

func contentCompressionResistancePriority(_ priority: UILayoutPriority, for axis: NSLayoutConstraint.Axis) -> Self

```

#### sample

```swift
self.declarative {
    UIView()
        .tag(1)
        .backgroundColor(.red)
        .isUserInteractionEnabled(false)
        .clipsToBounds(true)
        .contentMode(.scaleToFill)
        .alpha(0.5)
        .isHidden(false)
        .transform(.init(rotationAngle: 45.0/(2*Double.pi)))
        .contentHuggingPriority(.defaultHigh, for: .vertical)
        .contentCompressionResistancePriority(.defaultHigh, for: .vertical)
}
```

## contentPriorities

Method to set `ContentHuggingPriority` and `ContentCompressionResistancePriority` at the same time

```swift
func contentPriorities(_ priorities: UIContentPriorities) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| priorities | UIContentPriorities | contentHuggingPriorityとcontentCompressionResistancePriorityを決めるパラメータ、デフォルトは全て`nil`のためクラスの設定に準拠する |

#### sample

```swift
self.declarative {
    // Set all horizontal and vertical of 
    // contentHuggingPriority and
    // all horizontal and vertical of 
    // contentCompressionResistancePriority
    // to .required
    UILabel("contents")
      .contentPriorities(.init(all: .required))
      .center()
}
```

## cornerRadius

Method for rounding corners.

```swift
func cornerRadius(_ radius: CGFloat, maskedCorners: CACornerMask) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| radius | CGFloat | Parameters to determine how rounded to be. |
| maskedCorners | CACornerMask | Parameters to determine which of the four corners should be rounded, defaults to `[.layerMinXMaxYCorner, .layerMaxXMaxYCorner, .layerMaxXMinYCorner, .layerMinXMinYCorner]`. |

#### sample

```swift
self.declarative(priorities: .init(top: .required, leading: .required, bottom: .defaultLow, trailing: .defaultLow)) {
    UIView()
        .size(width: 100, height: 100)
        .cornerRadius(50, maskedCorners: [.layerMinXMaxYCorner, .layerMaxXMaxYCorner, .layerMaxXMinYCorner, .layerMinXMinYCorner])
        .backgroundColor(.red)
}
```

## border

Bordering method.

```swift
func border(color: UIColor, width: CGFloat) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| color | UIColor | line color |
| width | CGFloat | line thickness |

### sample
```swift
self.declarative(priorities: .init(top: .required, leading: .required, bottom: .defaultLow, trailing: .defaultLow)) {
    UIView()
        .size(width: 100, height: 100)
        .border(color: .red, width: 10)
}
```

## shadow

A method to add shadows.

```swift
func shadow(color: UIColor, radius: CGFloat, x: CGFloat, y: CGFloat) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| color | UIColor | Shadow color, default `black` |
| radius | CGFloat | Shadow power, default `0` |
| x | CGFloat | Shadow offset x, default `0` |
| y | CGFloat | Shadow offset y, default `0` |

### sample
```swift
self.declarative(priorities: .init(top: .required, leading: .required, bottom: .defaultLow, trailing: .defaultLow)) {
    UIView()
        .size(width: 100, height: 100)
        .backgroundColor(.white)
        .shadow(color: .black, radius: 10, x: 10, y: 10)
}
```

## add gesture

It is a method of attaching a gesture

```swift
func add(gestureRecognizer: UIGestureRecognizer) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| gestureRecognizer | UIGestureRecognizer | gesture |

```swift
func addGestureRecognizer(_ gestureBuilder: () -> UIGestureRecognizer) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| gestureBuilder | () -> UIGestureRecognizer | Declaratively set gestures |

### sample

```swift
let tap = UITapGestureRecognizer(target: self, action: #selector(tapView))

self.declarative {
    UIStackView {
        UIView()
            .add(gestureRecognizer: tap)

        UIView()
            .addGestureRecognizer {
                UITapGestureRecognizer(target: self) {
                    #selector(tapView)
                }
            }
    }
}
```

## zStack

This method overlaps the View in the z-direction.  
Paste a View generated by builder with the same size as itself.

```swift
func addSubview(margin: UIEdgeInsets, priorities: UIEdgePriorities,
    @ArrayUIViewBuilder _ builder: () -> [UIView?]) -> Self

func zStack(margin: UIEdgeInsets, priorities: UIEdgePriorities,
    @ArrayUIViewBuilder _ builder: () -> [UIView?]) -> Self
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| margin | UIEdgeInsets | Margins to be attached to the four corners |
| priorities | UIEdgePriorities | Priority of constraints at the four corners |
| builder | () -> [UIView?] | Declaratively set the View |

### sample

```swift
self.declarative {
    UIView.spacer()
        .backgroundColor(.red)
        .zStack(
            margin: .init(top: 10, left: 10, bottom: 10, right: 10),
            priorities: .init(top: .required, leading: .required, bottom: .defaultLow, trailing: .required)
        ) {
            UIView.spacer().height(100).backgroundColor(.blue)
        }
}
```

## padding

Generates a margin around its own View  
  
This is accomplished by creating another View behind its own View in the z-direction.  
Therefore, any methods declared after this method will be set to the view behind it.

```swift
func padding(value: CGFloat, touchTransparency: Bool, priorities: UIEdgePriorities) -> UIView

func padding(insets: UIEdgeInsets, touchTransparency: Bool, priorities: UIEdgePriorities) -> UIView
```

|  parameter | 型 | description |
| ---- | ---- | ---- |
| value | CGFloat | Margins to be attached to the four corners |
| touchTransparency | Bool |  Whether to make the spread margin touch transparent, defaults to `true |
| priorities | UIEdgePriorities | Priority of margins and own four corner constraints, defaults to all `required`. |

|  parameter | 型 | description |
| ---- | ---- | ---- |
| inserts | UIEdgeInsets | Margins to be attached to the four corners (individually) |

### sample

Here is an example of attaching a blue View with a margin of 20 around a red View

```swift
self.declarative {
    UIView()
        .backgroundColor(.red)
        .padding(insets: .init(all: 20))
        .backgroundColor(.blue)
}

```

## center

Center the View on the parent view.  
  
This is accomplished by overlapping the View with the StackView's horizontal and vertical and setting the alignment to center.  
Therefore, any methods declared after this method will be set to the view behind it.
centerX()` and `centerY()` will center the view only in the X and Y directions, respectively.

```swift
func center() -> UIView

func centerX() -> UIView

func centerY() -> UIView
```
### sample

Place the red view in the center of the screen

```swift
self.declarative {
    UIView()
        .backgroundColor(.red)
        .size(width: 100, height: 100)
        .center()
}

```

## touch actions

Method to put a view that receives touch actions on top of itself.
The `view` held by `Set<UITouch>` will therefore no longer be itself.

```swift
func touches(
        beganHandler: ((Set<UITouch>, UIEvent?) -> Void)? = nil,
        endedHandler: ((Set<UITouch>, UIEvent?) -> Void)? = nil,
        movedHandler: ((Set<UITouch>, UIEvent?) -> Void)? = nil,
        cancelledHandler: ((Set<UITouch>, UIEvent?) -> Void)? = nil,
        estimatedPropertiesUpdatedHandler: ((Set<UITouch>) -> Void)? = nil
    ) -> UIView
```

### sample

```swift
self.declarative {
    
    UIView()
        .backgroundColor(.white)
        .width(250).height(200)
        .touches(beganHandler: { touches, event in
            
            let touche = touches.first!
            let point = touche.location(in: touche.view)
            print("began: \(point)")

        }, endedHandler: { touches, event in

            let touche = touches.first!
            let point = touche.location(in: touche.view)
            print("ended: \(point)")

        }, movedHandler: { touches, event in

            let touche = touches.first!
            let point = touche.location(in: touche.view)
            print("moved: \(point)")

        }, cancelledHandler: { touches, event in

            let touche = touches.first!
            let point = touche.location(in: touche.view)
            print("cancelled: \(point)")

        }, estimatedPropertiesUpdatedHandler: { touches in

            let touche = touches.first!
            let point = touche.location(in: touche.view)
            print("estimatedPropertiesUpdated: \(point)")

        })
        .center()
}
```
## drawing graphics

Static method to describe drawing with `UIBezierPath`.  
`HelperPathView` is a subclass of UIView that internally draws the path.

```swift
static func path(_ imperativeBezierPath: @escaping () -> Void) -> HelperPathView
```

### sample

```swift
self.declarative {
    UIView.path {
        UIBezierPath.imperative {
            $0.move(to: .init(x: 100, y: 100))
            $0.addLine(to: .init(x: 300, y: 300))
        }.stroke(.black, lineWidth: 10)

        UIBezierPath.imperative {
            $0.move(to: .init(x: 300, y: 300))
            $0.addLine(to: .init(x: 100, y: 500))
        }.stroke(.red, lineWidth: 10)
    }
}
```

## constraint

Methods for affixing `Autolayout` constraints.  
Fixed numeric values can be specified as follows  
You cannot have conflicting values in `width`, `minWidth`, and `maxWidth` at the same time.  
The same applies to `height` and `size`.

```swift
func width(_ width: CGFloat, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self

func minWidth(_ width: CGFloat, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self

func maxWidth(_ width: CGFloat, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self

func height(_ height: CGFloat, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self

func minHeight(_ height: CGFloat, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self

func maxHeight(_ height: CGFloat, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self

func size(width: CGFloat, height: CGFloat, widthPriority: UILayoutPriority = .required, heightPriority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint, NSLayoutConstraint) -> Void)? = nil) -> Self

func minSize(width: CGFloat, height: CGFloat, widthPriority: UILayoutPriority = .required, heightPriority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint, NSLayoutConstraint) -> Void)? = nil) -> Self

func maxSize(width: CGFloat, height: CGFloat, widthPriority: UILayoutPriority = .required, heightPriority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint, NSLayoutConstraint) -> Void)? = nil) -> Self
```

Constraint that relates two Views.  
`constraint` supports `+-*/`.

```swift
func widthEqual(to superview: UIView, constraint: NSLayoutDimension, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self

func heightEqual(to superview: UIView, constraint: NSLayoutDimension, priority: UILayoutPriority = .required, imperative: ((NSLayoutConstraint) -> Void)? = nil) -> Self
```

### sample

```swift
self.declarative {
    UIView()
        .width(100)
        .minWidth(100, priority: .defaultHight)
        .maxWidth(100) { constraint in 
          constraint.priority = .defaultLow
        }
        .height(100)
        .minHeight(100)
        .maxHeight(100)
        .size(width: 100, height: 100)
        .minSize(width: 100, height: 100, widthPriority: .required, heightPriority: .defaultHight)
        .maxSize(width: 100, height: 100) { (widthLayoutConstraint, heightLayoutConstraint) in 
          widthLayoutConstraint.isActive = false
          heightLayoutConstraint.priority = .required
        }
}
```

```swift
self.declarative {
  UIStackView { superview in
    UIView.spacer().backgroundColor(.red)
          .widthEqual(to: superview, constraint: superview.widthAnchor / 2 + 30)
          .heightEqual(to: superview, constraint: superview.heightAnchor / 2 - 50, priority: .defaultHight) { constraint in 
            constraint.isActive = false
          }

    UIView.spacer()
  }
  .alignment(.center)
}
```